Index: Sources/Controls/VideoSourcePlayer.cs
===================================================================
--- Sources/Controls/VideoSourcePlayer.cs	(revision 1699)
+++ Sources/Controls/VideoSourcePlayer.cs	(working copy)
@@ -70,8 +70,9 @@
         // controls border color
         private Color borderColor = Color.Black;
 
-        private Size frameSize = new Size( 320, 240 );
+        private Size frameSize = new Size(320, 240);
         private bool autosize = false;
+        private bool keepRatio = false; 
         private bool needSizeUpdate = false;
         private bool firstFrameNotProcessed = true;
         private volatile bool requestedToStop = false;
@@ -80,7 +81,7 @@
         private Control parent = null;
 
         // dummy object to lock for synchronization
-        private object sync = new object( );
+        private object sync = new object();
 
         /// <summary>
         /// Auto size control or not.
@@ -95,16 +96,32 @@
         /// <see cref="Control.Dock"/> property is set to <see cref="DockStyle.Fill"/>.</note></para>
         /// </remarks>
         /// 
-        [DefaultValue( false )]
+        [DefaultValue(false)]
         public bool AutoSizeControl
         {
             get { return autosize; }
             set
             {
                 autosize = value;
-                UpdatePosition( );
+                UpdatePosition();
             }
         }
+        
+        /// <summary>
+        ///   Gets or sets whether the player should keep
+        ///   the aspect ratio of the images being shown.
+        /// </summary>
+        /// 
+        [DefaultValue(false)]
+        public bool KeepAspectRatio
+        {
+            get { return keepRatio; }
+            set
+            {
+                keepRatio = value;
+                Invalidate();
+            }
+        }
 
         /// <summary>
         /// Control's border color.
@@ -112,14 +129,14 @@
         /// 
         /// <remarks><para>Specifies color of the border drawn around video frame.</para></remarks>
         /// 
-        [DefaultValue( typeof( Color ), "Black" )]
+        [DefaultValue(typeof(Color), "Black")]
         public Color BorderColor
         {
             get { return borderColor; }
             set
             {
                 borderColor = value;
-                Invalidate( );
+                Invalidate();
             }
         }
 
@@ -138,27 +155,27 @@
         /// 
         /// <exception cref="Exception">Video source can not be changed while current video source is still running.</exception>
         /// 
-        [Browsable( false )]
+        [Browsable(false)]
         public IVideoSource VideoSource
         {
             get { return videoSource; }
             set
             {
-                CheckForCrossThreadAccess( );
+                CheckForCrossThreadAccess();
 
                 // detach events
-                if ( videoSource != null )
+                if (videoSource != null)
                 {
-                    videoSource.NewFrame -= new NewFrameEventHandler( videoSource_NewFrame );
-                    videoSource.VideoSourceError -= new VideoSourceErrorEventHandler( videoSource_VideoSourceError );
-                    videoSource.PlayingFinished -= new PlayingFinishedEventHandler( videoSource_PlayingFinished );
+                    videoSource.NewFrame -= new NewFrameEventHandler(videoSource_NewFrame);
+                    videoSource.VideoSourceError -= new VideoSourceErrorEventHandler(videoSource_VideoSourceError);
+                    videoSource.PlayingFinished -= new PlayingFinishedEventHandler(videoSource_PlayingFinished);
                 }
 
-                lock ( sync )
+                lock (sync)
                 {
-                    if ( currentFrame != null )
+                    if (currentFrame != null)
                     {
-                        currentFrame.Dispose( );
+                        currentFrame.Dispose();
                         currentFrame = null;
                     }
                 }
@@ -166,22 +183,22 @@
                 videoSource = value;
 
                 // atach events
-                if ( videoSource != null )
+                if (videoSource != null)
                 {
-                    videoSource.NewFrame += new NewFrameEventHandler( videoSource_NewFrame );
-                    videoSource.VideoSourceError += new VideoSourceErrorEventHandler( videoSource_VideoSourceError );
-                    videoSource.PlayingFinished += new PlayingFinishedEventHandler( videoSource_PlayingFinished );
+                    videoSource.NewFrame += new NewFrameEventHandler(videoSource_NewFrame);
+                    videoSource.VideoSourceError += new VideoSourceErrorEventHandler(videoSource_VideoSourceError);
+                    videoSource.PlayingFinished += new PlayingFinishedEventHandler(videoSource_PlayingFinished);
                 }
                 else
                 {
-                    frameSize = new Size( 320, 240 );
+                    frameSize = new Size(320, 240);
                 }
 
                 lastMessage = null;
                 needSizeUpdate = true;
                 firstFrameNotProcessed = true;
                 // update the control
-                Invalidate( );
+                Invalidate();
             }
         }
 
@@ -191,14 +208,14 @@
         /// 
         /// <remarks><para>Current state of the current video source object - running or not.</para></remarks>
         /// 
-        [Browsable( false )]
+        [Browsable(false)]
         public bool IsRunning
         {
             get
             {
-                CheckForCrossThreadAccess( );
+                CheckForCrossThreadAccess();
 
-                return ( videoSource != null ) ? videoSource.IsRunning : false;
+                return (videoSource != null) ? videoSource.IsRunning : false;
             }
         }
 
@@ -209,7 +226,7 @@
         /// <param name="sender">Event sender.</param>
         /// <param name="image">New frame.</param>
         /// 
-        public delegate void NewFrameHandler( object sender, ref Bitmap image );
+        public delegate void NewFrameHandler(object sender, ref Bitmap image);
 
         /// <summary>
         /// New frame event.
@@ -238,51 +255,51 @@
         /// <summary>
         /// Initializes a new instance of the <see cref="VideoSourcePlayer"/> class.
         /// </summary>
-        public VideoSourcePlayer( )
+        public VideoSourcePlayer()
         {
-            InitializeComponent( );
+            InitializeComponent();
 
             // update control style
-            SetStyle( ControlStyles.AllPaintingInWmPaint | ControlStyles.ResizeRedraw |
-                ControlStyles.DoubleBuffer | ControlStyles.UserPaint, true );
+            SetStyle(ControlStyles.AllPaintingInWmPaint | ControlStyles.ResizeRedraw |
+                ControlStyles.DoubleBuffer | ControlStyles.UserPaint, true);
         }
 
         // Check if the control is accessed from a none UI thread
-        private void CheckForCrossThreadAccess( )
+        private void CheckForCrossThreadAccess()
         {
             // force handle creation, so InvokeRequired() will use it instead of searching through parent's chain
-            if ( !IsHandleCreated )
+            if (!IsHandleCreated)
             {
-                CreateControl( );
+                CreateControl();
 
                 // if the control is not Visible, then CreateControl() will not be enough
-                if ( !IsHandleCreated )
+                if (!IsHandleCreated)
                 {
-                    CreateHandle( );
+                    CreateHandle();
                 }
             }
 
-            if ( InvokeRequired )
+            if (InvokeRequired)
             {
-                throw new InvalidOperationException( "Cross thread access to the control is not allowed." );
+                throw new InvalidOperationException("Cross thread access to the control is not allowed.");
             }
         }
 
         /// <summary>
         /// Start video source and displaying its frames.
         /// </summary>
-        public void Start( )
+        public void Start()
         {
-            CheckForCrossThreadAccess( );
+            CheckForCrossThreadAccess();
 
             requestedToStop = false;
 
-            if ( videoSource != null )
+            if (videoSource != null)
             {
                 firstFrameNotProcessed = true;
 
-                videoSource.Start( );
-                Invalidate( );
+                videoSource.Start();
+                Invalidate();
             }
         }
 
@@ -296,23 +313,23 @@
         /// video source to perform proper shut down and clean up.
         /// </para></remarks>
         /// 
-        public void Stop( )
+        public void Stop()
         {
-            CheckForCrossThreadAccess( );
+            CheckForCrossThreadAccess();
 
             requestedToStop = true;
 
-            if ( videoSource != null )
+            if (videoSource != null)
             {
-                videoSource.Stop( );
+                videoSource.Stop();
 
-                if ( currentFrame != null )
+                if (currentFrame != null)
                 {
-                    currentFrame.Dispose( );
+                    currentFrame.Dispose();
                     currentFrame = null;
                 }
 
-                Invalidate( );
+                Invalidate();
             }
         }
 
@@ -323,15 +340,15 @@
         /// <remarks><para>Use <see cref="WaitForStop"/> method to wait until video source
         /// stops.</para></remarks>
         /// 
-        public void SignalToStop( )
+        public void SignalToStop()
         {
-            CheckForCrossThreadAccess( );
+            CheckForCrossThreadAccess();
 
             requestedToStop = true;
 
-            if ( videoSource != null )
+            if (videoSource != null)
             {
-                videoSource.SignalToStop( );
+                videoSource.SignalToStop();
             }
         }
 
@@ -343,26 +360,26 @@
         /// <see cref="SignalToStop"/> method. If <see cref="SignalToStop"/> was not called, then
         /// it will be called automatically.</para></remarks>
         /// 
-        public void WaitForStop( )
+        public void WaitForStop()
         {
-            CheckForCrossThreadAccess( );
+            CheckForCrossThreadAccess();
 
-            if ( !requestedToStop )
+            if (!requestedToStop)
             {
-                SignalToStop( );
+                SignalToStop();
             }
 
-            if ( videoSource != null )
+            if (videoSource != null)
             {
-                videoSource.WaitForStop( );
+                videoSource.WaitForStop();
 
-                if ( currentFrame != null )
+                if (currentFrame != null)
                 {
-                    currentFrame.Dispose( );
+                    currentFrame.Dispose();
                     currentFrame = null;
                 }
 
-                Invalidate( );
+                Invalidate();
             }
         }
 
@@ -375,137 +392,162 @@
         /// control did not receive any video frames yet, then the method returns
         /// <see langword="null"/>.</returns>
         /// 
-        public Bitmap GetCurrentVideoFrame( )
+        public Bitmap GetCurrentVideoFrame()
         {
-            lock ( sync )
+            lock (sync)
             {
-                return ( currentFrame == null ) ? null : AForge.Imaging.Image.Clone( currentFrame );
+                return (currentFrame == null) ? null : AForge.Imaging.Image.Clone(currentFrame);
             }
         }
 
         // Paing control
-        private void VideoSourcePlayer_Paint( object sender, PaintEventArgs e )
+        private void VideoSourcePlayer_Paint(object sender, PaintEventArgs e)
         {
             // is it required to update control's size/position
-            if ( ( needSizeUpdate ) || ( firstFrameNotProcessed ) )
+            if ((needSizeUpdate) || (firstFrameNotProcessed))
             {
-                UpdatePosition( );
+                UpdatePosition();
                 needSizeUpdate = false;
             }
 
-            lock ( sync )
+            lock (sync)
             {
-                Graphics  g = e.Graphics;
+                Graphics g = e.Graphics;
                 Rectangle rect = this.ClientRectangle;
-                Pen       borderPen = new Pen( borderColor, 1 );
+                Pen borderPen = new Pen(borderColor, 1);
 
+
+
                 // draw rectangle
-                g.DrawRectangle( borderPen, rect.X, rect.Y, rect.Width - 1, rect.Height - 1 );
+                g.DrawRectangle(borderPen, rect.X, rect.Y, rect.Width - 1, rect.Height - 1);
 
-                if ( videoSource != null )
+                if (videoSource != null)
                 {
-                    if ( ( currentFrame != null ) && ( lastMessage == null ) )
+                    if ((currentFrame != null) && (lastMessage == null))
                     {
-                        // draw current frame
-                        g.DrawImage( ( convertedFrame != null ) ? convertedFrame : currentFrame,
-                            rect.X + 1, rect.Y + 1, rect.Width - 2, rect.Height - 2 );
+                        Bitmap frame = (convertedFrame != null) ? convertedFrame : currentFrame;
+
+                        if (keepRatio)
+                        {
+                            double ratio = frame.Width / (double)frame.Height;
+
+                            Rectangle newRect = rect;
+
+                            if (rect.Width < rect.Height * ratio)
+                                newRect.Height = (int)(rect.Width / ratio);
+                            else
+                                newRect.Width = (int)(rect.Height * ratio);
+
+                            newRect.X = rect.Width / 2 - newRect.Width / 2;
+                            newRect.Y = rect.Height / 2 - newRect.Height / 2;
+
+                            g.DrawImage(frame, newRect.X + 1, newRect.Y + 1,
+                              newRect.Width - 2, newRect.Height - 2);
+                        }
+                        else
+                        {
+                            // draw current frame
+                            g.DrawImage(frame, rect.X + 1, rect.Y + 1,
+                                rect.Width - 2, rect.Height - 2);
+                        }
+
                         firstFrameNotProcessed = false;
                     }
                     else
                     {
                         // create font and brush
-                        SolidBrush drawBrush = new SolidBrush( this.ForeColor );
+                        SolidBrush drawBrush = new SolidBrush(this.ForeColor);
 
-                        g.DrawString( ( lastMessage == null ) ? "Connecting ..." : lastMessage,
-                            this.Font, drawBrush, new PointF( 5, 5 ) );
+                        g.DrawString((lastMessage == null) ? "Connecting ..." : lastMessage,
+                            this.Font, drawBrush, new PointF(5, 5));
 
-                        drawBrush.Dispose( );
+                        drawBrush.Dispose();
                     }
                 }
 
-                borderPen.Dispose( );
+                borderPen.Dispose();
             }
         }
 
         // Update controls size and position
-        private void UpdatePosition( )
+        private void UpdatePosition()
         {
-            if ( ( autosize ) && ( this.Dock != DockStyle.Fill ) && ( this.Parent != null ) )
+            if ((autosize) && (this.Dock != DockStyle.Fill) && (this.Parent != null))
             {
                 Rectangle rc = this.Parent.ClientRectangle;
-                int width  = frameSize.Width;
+                int width = frameSize.Width;
                 int height = frameSize.Height;
 
                 // update controls size and location
-                this.SuspendLayout( );
-                this.Location = new Point( ( rc.Width - width - 2 ) / 2, ( rc.Height - height - 2 ) / 2 );
-                this.Size = new Size( width + 2, height + 2 );
-                this.ResumeLayout( );
+                this.SuspendLayout();
+                this.Location = new Point((rc.Width - width - 2) / 2, (rc.Height - height - 2) / 2);
+                this.Size = new Size(width + 2, height + 2);
+                this.ResumeLayout();
             }
         }
 
         // On new frame ready
-        private void videoSource_NewFrame( object sender, NewFrameEventArgs eventArgs )
+        private void videoSource_NewFrame(object sender, NewFrameEventArgs eventArgs)
         {
-            if ( !requestedToStop )
+            if (!requestedToStop)
             {
-                Bitmap newFrame = (Bitmap) eventArgs.Frame.Clone( );
+                Bitmap newFrame = (Bitmap)eventArgs.Frame.Clone();
 
                 // let user process the frame first
-                if ( NewFrame != null )
+                if (NewFrame != null)
                 {
-                    NewFrame( this, ref newFrame );
+                    NewFrame(this, ref newFrame);
                 }
 
                 // now update current frame of the control
-                lock ( sync )
+                lock (sync)
                 {
                     // dispose previous frame
-                    if ( currentFrame != null )
+                    if (currentFrame != null)
                     {
-                        if ( currentFrame.Size != eventArgs.Frame.Size )
+                        if (currentFrame.Size != eventArgs.Frame.Size)
                         {
                             needSizeUpdate = true;
                         }
 
-                        currentFrame.Dispose( );
+                        currentFrame.Dispose();
                         currentFrame = null;
                     }
-                    if ( convertedFrame != null )
+                    if (convertedFrame != null)
                     {
-                        convertedFrame.Dispose( );
+                        convertedFrame.Dispose();
                         convertedFrame = null;
                     }
 
                     currentFrame = newFrame;
-                    frameSize    = currentFrame.Size;
-                    lastMessage  = null;
+                    frameSize = currentFrame.Size;
+                    lastMessage = null;
 
                     // check if conversion is required to lower bpp rate
-                    if ( ( currentFrame.PixelFormat == PixelFormat.Format16bppGrayScale ) ||
-                         ( currentFrame.PixelFormat == PixelFormat.Format48bppRgb ) ||
-                         ( currentFrame.PixelFormat == PixelFormat.Format64bppArgb ) )
+                    if ((currentFrame.PixelFormat == PixelFormat.Format16bppGrayScale) ||
+                         (currentFrame.PixelFormat == PixelFormat.Format48bppRgb) ||
+                         (currentFrame.PixelFormat == PixelFormat.Format64bppArgb))
                     {
-                        convertedFrame = AForge.Imaging.Image.Convert16bppTo8bpp( currentFrame );
+                        convertedFrame = AForge.Imaging.Image.Convert16bppTo8bpp(currentFrame);
                     }
                 }
 
                 // update control
-                Invalidate( );
+                Invalidate();
             }
         }
 
         // Error occured in video source
-        private void videoSource_VideoSourceError( object sender, VideoSourceErrorEventArgs eventArgs )
+        private void videoSource_VideoSourceError(object sender, VideoSourceErrorEventArgs eventArgs)
         {
             lastMessage = eventArgs.Description;
-            Invalidate( );
+            Invalidate();
         }
 
         // Video source has finished playing video
-        private void videoSource_PlayingFinished( object sender, ReasonToFinishPlaying reason )
+        private void videoSource_PlayingFinished(object sender, ReasonToFinishPlaying reason)
         {
-            switch ( reason )
+            switch (reason)
             {
                 case ReasonToFinishPlaying.EndOfStreamReached:
                     lastMessage = "Video has finished";
@@ -527,36 +569,36 @@
                     lastMessage = "Video has finished for unknown reason";
                     break;
             }
-            Invalidate( );
+            Invalidate();
 
             // notify users
-            if ( PlayingFinished != null )
+            if (PlayingFinished != null)
             {
-                PlayingFinished( this, reason );
+                PlayingFinished(this, reason);
             }
         }
 
         // Parent Changed event handler
-        private void VideoSourcePlayer_ParentChanged( object sender, EventArgs e )
+        private void VideoSourcePlayer_ParentChanged(object sender, EventArgs e)
         {
-            if ( parent != null )
+            if (parent != null)
             {
-                parent.SizeChanged -= new EventHandler( parent_SizeChanged );
+                parent.SizeChanged -= new EventHandler(parent_SizeChanged);
             }
 
             parent = this.Parent;
 
             // set handler for Size Changed parent's event
-            if ( parent != null )
+            if (parent != null)
             {
-                parent.SizeChanged += new EventHandler( parent_SizeChanged );
+                parent.SizeChanged += new EventHandler(parent_SizeChanged);
             }
         }
 
         // Parent control has changed its size
-        private void parent_SizeChanged( object sender, EventArgs e )
+        private void parent_SizeChanged(object sender, EventArgs e)
         {
-            UpdatePosition( );
+            UpdatePosition();
         }
     }
 }
Index: Sources/Video.FFMPEG/AssemblyInfo.cpp
===================================================================
--- Sources/Video.FFMPEG/AssemblyInfo.cpp	(revision 1699)
+++ Sources/Video.FFMPEG/AssemblyInfo.cpp	(working copy)
@@ -39,3 +39,5 @@
 [assembly:CLSCompliantAttribute(true)];
 
 [assembly:SecurityPermission(SecurityAction::RequestMinimum, UnmanagedCode = true)];
+[assembly:AssemblyKeyFileAttribute("AForge.Video.FFMPEG.snk")];
+[assembly:AssemblyDelaySignAttribute(true)];
Index: Sources/Video.FFMPEG/Video.FFMPEG.vcxproj
===================================================================
--- Sources/Video.FFMPEG/Video.FFMPEG.vcxproj	(revision 1699)
+++ Sources/Video.FFMPEG/Video.FFMPEG.vcxproj	(working copy)
@@ -22,11 +22,13 @@
     <CharacterSet>Unicode</CharacterSet>
     <CLRSupport>true</CLRSupport>
     <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v100</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
     <ConfigurationType>DynamicLibrary</ConfigurationType>
     <CharacterSet>Unicode</CharacterSet>
     <CLRSupport>true</CLRSupport>
+    <PlatformToolset>v100</PlatformToolset>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
   <ImportGroup Label="ExtensionSettings">
Index: Sources/Video.FFMPEG/VideoCodec.cpp
===================================================================
--- Sources/Video.FFMPEG/VideoCodec.cpp	(revision 1699)
+++ Sources/Video.FFMPEG/VideoCodec.cpp	(working copy)
@@ -29,7 +29,10 @@
 	libffmpeg::CODEC_ID_H263P,
 	libffmpeg::CODEC_ID_FLV1,
 	libffmpeg::CODEC_ID_MPEG2VIDEO,
-	libffmpeg::CODEC_ID_RAWVIDEO
+	libffmpeg::CODEC_ID_RAWVIDEO,
+	libffmpeg::CODEC_ID_FFV1,
+	libffmpeg::CODEC_ID_FFVHUFF,  
+	libffmpeg::CODEC_ID_H264,
 };
 
 int pixel_formats[] =
@@ -43,6 +46,9 @@
 	libffmpeg::PIX_FMT_YUV420P,
 	libffmpeg::PIX_FMT_YUV420P,
 	libffmpeg::PIX_FMT_BGR24,
+	libffmpeg::PIX_FMT_YUV420P,
+	libffmpeg::PIX_FMT_RGB32,
+	libffmpeg::PIX_FMT_YUVJ420P,
 };
 
 int CODECS_COUNT ( sizeof( video_codecs ) / sizeof( libffmpeg::CodecID ) );
\ No newline at end of file
Index: Sources/Video.FFMPEG/VideoCodec.h
===================================================================
--- Sources/Video.FFMPEG/VideoCodec.h	(revision 1699)
+++ Sources/Video.FFMPEG/VideoCodec.h	(working copy)
@@ -62,6 +62,18 @@
 		/// Raw (uncompressed) video.
 		/// </summary>
 		Raw,
+		/// <summary>
+		/// FF video codec 1 lossless codec.
+		/// </summary>
+		FFV1,
+		/// <summary>
+		/// FFmpeg's HuffYUV lossless codec.
+		/// </summary>
+		FFVHUFF,
+		/// <summary>
+		/// H.264/MPEG-4 Part 10.
+		/// </summary>
+        H264,
 	};
 
 } } }
\ No newline at end of file
Index: Sources/Video.FFMPEG/VideoFileWriter.cpp
===================================================================
--- Sources/Video.FFMPEG/VideoFileWriter.cpp	(revision 1699)
+++ Sources/Video.FFMPEG/VideoFileWriter.cpp	(working copy)
@@ -143,9 +143,9 @@
 		data->FormatContext->oformat = outputFormat;
 
 		// add video stream using the specified video codec
-		add_video_stream( data, width, height, frameRate, bitRate,
-			( codec == VideoCodec::Default ) ? outputFormat->video_codec : (libffmpeg::CodecID) video_codecs[(int) codec],
-			( codec == VideoCodec::Default ) ? libffmpeg::PIX_FMT_YUV420P : (libffmpeg::PixelFormat) pixel_formats[(int) codec] );
+		 add_video_stream( data, width, height, frameRate, bitRate,
+                        ( codec == VideoCodec::Default ) ? outputFormat->video_codec : (libffmpeg::CodecID) video_codecs[(int) codec],
+                        ( codec == VideoCodec::Default ) ? libffmpeg::PIX_FMT_YUV420P : (libffmpeg::PixelFormat) pixel_formats[(int) codec] );
 
 		// set the output parameters (must be done even if no parameters)
 		if ( libffmpeg::av_set_parameters( data->FormatContext, NULL ) < 0 )
@@ -383,47 +383,76 @@
 void add_video_stream( WriterPrivateData^ data,  int width, int height, int frameRate, int bitRate,
 					  enum libffmpeg::CodecID codecId, enum libffmpeg::PixelFormat pixelFormat )
 {
-	libffmpeg::AVCodecContext* codecContex;
+	    libffmpeg::AVCodec *codec = libffmpeg::avcodec_find_encoder(codecId);
+        libffmpeg::AVCodecContext* codecContex;
+        // create new stream
+        data->VideoStream = libffmpeg::avformat_new_stream( data->FormatContext, codec );
+        if ( !data->VideoStream )
+        {
+                throw gcnew VideoException( "Failed creating new video stream." );
+        }
+        
+        codecContex = data->VideoStream->codec;
+        codecContex->codec_id   = codecId;
+        codecContex->codec_type = libffmpeg::AVMEDIA_TYPE_VIDEO;
 
-	// create new stream
-	data->VideoStream = libffmpeg::av_new_stream( data->FormatContext, 0 );
-	if ( !data->VideoStream )
-	{
-		throw gcnew VideoException( "Failed creating new video stream." );
-	}
+        // put sample parameters
+        codecContex->bit_rate = bitRate;
+        codecContex->width    = width;
+        codecContex->height   = height;
 
-	codecContex = data->VideoStream->codec;
-	codecContex->codec_id   = codecId;
-	codecContex->codec_type = libffmpeg::AVMEDIA_TYPE_VIDEO;
+        // time base: this is the fundamental unit of time (in seconds) in terms
+        // of which frame timestamps are represented. for fixed-fps content,
+        // timebase should be 1/framerate and timestamp increments should be
+        // identically 1.
+        codecContex->time_base.den = frameRate;
+	    codecContex->time_base.num = 1;
 
-	// put sample parameters
-	codecContex->bit_rate = bitRate;
-	codecContex->width    = width;
-	codecContex->height   = height;
+	    codecContex->gop_size = 12; // emit one intra frame every twelve frames at most
+        codecContex->pix_fmt  = pixelFormat;
 
-	// time base: this is the fundamental unit of time (in seconds) in terms
-	// of which frame timestamps are represented. for fixed-fps content,
-	// timebase should be 1/framerate and timestamp increments should be
-	// identically 1.
-	codecContex->time_base.den = frameRate;
-	codecContex->time_base.num = 1;
+        if ( codecContex->codec_id == libffmpeg::CODEC_ID_MPEG1VIDEO )
+        {
+                // Needed to avoid using macroblocks in which some coeffs overflow.
+                // This does not happen with normal video, it just happens here as
+                // the motion of the chroma plane does not match the luma plane.
+                codecContex->mb_decision = 2;
+        }
 
-	codecContex->gop_size = 12; // emit one intra frame every twelve frames at most
-	codecContex->pix_fmt  = pixelFormat;
+        if ( codecContex->codec_id == libffmpeg::CODEC_ID_H264 )
+        {
+                data->VideoStream->need_parsing = libffmpeg::AVSTREAM_PARSE_FULL_ONCE;
 
-	if ( codecContex->codec_id == libffmpeg::CODEC_ID_MPEG1VIDEO )
-	{
-		// Needed to avoid using macroblocks in which some coeffs overflow.
-		// This does not happen with normal video, it just happens here as
-		// the motion of the chroma plane does not match the luma plane.
-		codecContex->mb_decision = 2;
-	}
+                codecContex->coder_type = 1; 
+                codecContex->flags|=CODEC_FLAG_LOOP_FILTER;
+				codecContex->flags2|=CODEC_FLAG2_BPYRAMID-CODEC_FLAG2_WPRED-CODEC_FLAG2_8X8DCT;
+                codecContex->profile=FF_PROFILE_H264_BASELINE;
+                codecContex->scenechange_threshold = 40; 
+				codecContex->gop_size=250;
+				codecContex->max_b_frames=0;
+				codecContex->max_qdiff=4;
+                codecContex->me_method=10;
+				codecContex->me_range=16;
+                codecContex->me_cmp|= 1;
+                codecContex->me_subpel_quality = 6; 
+				codecContex->qmin=0; 
+				codecContex->qmax=69;
+				codecContex->qcompress=0.6f;
+				codecContex->keyint_min=25;
+				codecContex->trellis=0;
+				codecContex->level=13;
+                codecContex->refs = 16;
+                codecContex->weighted_p_pred = 2;
+				codecContex->b_frame_strategy= 1;
+				codecContex->color_range = libffmpeg::AVCOL_RANGE_JPEG;
+                codecContex->crf = 0;
+        }
 
-	// some formats want stream headers to be separate
-	if( data->FormatContext->oformat->flags & AVFMT_GLOBALHEADER )
-	{
-		codecContex->flags |= CODEC_FLAG_GLOBAL_HEADER;
-	}
+        // some formats want stream headers to be separate
+        if( data->FormatContext->oformat->flags & AVFMT_GLOBALHEADER )
+        {
+                codecContex->flags |= CODEC_FLAG_GLOBAL_HEADER;
+        }
 }
 
 // Open video codec and prepare out buffer and picture
