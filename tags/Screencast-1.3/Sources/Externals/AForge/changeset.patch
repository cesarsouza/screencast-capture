Index: Sources/Controls/VideoSourcePlayer.cs
===================================================================
--- Sources/Controls/VideoSourcePlayer.cs	(revision 1699)
+++ Sources/Controls/VideoSourcePlayer.cs	(working copy)
@@ -72,6 +72,7 @@
 
         private Size frameSize = new Size( 320, 240 );
         private bool autosize = false;
+        private bool keepRatio = false; 
         private bool needSizeUpdate = false;
         private bool firstFrameNotProcessed = true;
         private volatile bool requestedToStop = false;
@@ -105,6 +106,22 @@
                 UpdatePosition( );
             }
         }
+        
+        /// <summary>
+        ///   Gets or sets whether the player should keep
+        ///   the aspect ratio of the images being shown.
+        /// </summary>
+        /// 
+        [DefaultValue( false )]
+        public bool KeepAspectRatio
+        {
+            get { return keepRatio; }
+            set
+            {
+                keepRatio = value;
+                Invalidate();
+            }
+        }
 
         /// <summary>
         /// Control's border color.
@@ -383,9 +400,12 @@
             }
         }
 
-        // Paing control
+        // Paint control
         private void VideoSourcePlayer_Paint( object sender, PaintEventArgs e )
         {
+            if (!Visible)
+                return;
+
             // is it required to update control's size/position
             if ( ( needSizeUpdate ) || ( firstFrameNotProcessed ) )
             {
@@ -406,9 +426,32 @@
                 {
                     if ( ( currentFrame != null ) && ( lastMessage == null ) )
                     {
-                        // draw current frame
-                        g.DrawImage( ( convertedFrame != null ) ? convertedFrame : currentFrame,
-                            rect.X + 1, rect.Y + 1, rect.Width - 2, rect.Height - 2 );
+                        Bitmap frame = (convertedFrame != null) ? convertedFrame : currentFrame;
+
+                        if (keepRatio)
+                        {
+                            double ratio = frame.Width / (double)frame.Height;
+
+                            Rectangle newRect = rect;
+
+                            if (rect.Width < rect.Height * ratio)
+                                newRect.Height = (int)(rect.Width / ratio);
+                            else
+                                newRect.Width = (int)(rect.Height * ratio);
+
+                            newRect.X = rect.Width / 2 - newRect.Width / 2;
+                            newRect.Y = rect.Height / 2 - newRect.Height / 2;
+
+                            g.DrawImage(frame, newRect.X + 1, newRect.Y + 1,
+                              newRect.Width - 2, newRect.Height - 2);
+                        }
+                        else
+                        {
+                            // draw current frame
+                            g.DrawImage(frame, rect.X + 1, rect.Y + 1,
+                                rect.Width - 2, rect.Height - 2);
+                        }
+
                         firstFrameNotProcessed = false;
                     }
                     else
Index: Sources/Video.FFMPEG/AssemblyInfo.cpp
===================================================================
--- Sources/Video.FFMPEG/AssemblyInfo.cpp	(revision 1699)
+++ Sources/Video.FFMPEG/AssemblyInfo.cpp	(working copy)
@@ -39,3 +39,5 @@
 [assembly:CLSCompliantAttribute(true)];
 
 [assembly:SecurityPermission(SecurityAction::RequestMinimum, UnmanagedCode = true)];
+[assembly:AssemblyKeyFileAttribute("AForge.Video.FFMPEG.snk")];
+[assembly:AssemblyDelaySignAttribute(true)];
Index: Sources/Video.FFMPEG/Video.FFMPEG.vcxproj
===================================================================
--- Sources/Video.FFMPEG/Video.FFMPEG.vcxproj	(revision 1699)
+++ Sources/Video.FFMPEG/Video.FFMPEG.vcxproj	(working copy)
@@ -22,11 +22,13 @@
     <CharacterSet>Unicode</CharacterSet>
     <CLRSupport>true</CLRSupport>
     <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v100</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
     <ConfigurationType>DynamicLibrary</ConfigurationType>
     <CharacterSet>Unicode</CharacterSet>
     <CLRSupport>true</CLRSupport>
+    <PlatformToolset>v100</PlatformToolset>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
   <ImportGroup Label="ExtensionSettings">
Index: Sources/Video.FFMPEG/VideoCodec.cpp
===================================================================
--- Sources/Video.FFMPEG/VideoCodec.cpp	(revision 1699)
+++ Sources/Video.FFMPEG/VideoCodec.cpp	(working copy)
@@ -29,7 +29,11 @@
 	libffmpeg::CODEC_ID_H263P,
 	libffmpeg::CODEC_ID_FLV1,
 	libffmpeg::CODEC_ID_MPEG2VIDEO,
-	libffmpeg::CODEC_ID_RAWVIDEO
+	libffmpeg::CODEC_ID_RAWVIDEO,
+	libffmpeg::CODEC_ID_FFV1,
+	libffmpeg::CODEC_ID_FFVHUFF,  
+	libffmpeg::CODEC_ID_H264,
+	libffmpeg::CODEC_ID_THEORA,
 };
 
 int pixel_formats[] =
@@ -43,6 +47,10 @@
 	libffmpeg::PIX_FMT_YUV420P,
 	libffmpeg::PIX_FMT_YUV420P,
 	libffmpeg::PIX_FMT_BGR24,
+	libffmpeg::PIX_FMT_YUV420P,
+	libffmpeg::PIX_FMT_RGB32,
+	libffmpeg::PIX_FMT_YUVJ420P,
+	libffmpeg::PIX_FMT_YUV420P,
 };
 
 int CODECS_COUNT ( sizeof( video_codecs ) / sizeof( libffmpeg::CodecID ) );
\ No newline at end of file
Index: Sources/Video.FFMPEG/VideoCodec.h
===================================================================
--- Sources/Video.FFMPEG/VideoCodec.h	(revision 1699)
+++ Sources/Video.FFMPEG/VideoCodec.h	(working copy)
@@ -62,6 +62,22 @@
 		/// Raw (uncompressed) video.
 		/// </summary>
 		Raw,
+		/// <summary>
+		/// FF video codec 1 lossless codec.
+		/// </summary>
+		FFV1,
+		/// <summary>
+		/// FFmpeg's HuffYUV lossless codec.
+		/// </summary>
+		FFVHUFF,
+		/// <summary>
+		/// H.264/MPEG-4 Part 10.
+		/// </summary>
+        H264,
+		/// <summary>
+		/// H.264/MPEG-4 Part 10.
+		/// </summary>
+        Theora,
 	};
 
 } } }
\ No newline at end of file
Index: Sources/Video.FFMPEG/VideoFileWriter.cpp
===================================================================
--- Sources/Video.FFMPEG/VideoFileWriter.cpp	(revision 1699)
+++ Sources/Video.FFMPEG/VideoFileWriter.cpp	(working copy)
@@ -119,7 +119,7 @@
 
 	try
 	{
-		// gues about destination file format from its file name
+		// guess about destination file format from its file name
 		libffmpeg::AVOutputFormat* outputFormat = libffmpeg::av_guess_format( NULL, nativeFileName, NULL );
 
 		if ( !outputFormat )
@@ -143,9 +143,9 @@
 		data->FormatContext->oformat = outputFormat;
 
 		// add video stream using the specified video codec
-		add_video_stream( data, width, height, frameRate, bitRate,
-			( codec == VideoCodec::Default ) ? outputFormat->video_codec : (libffmpeg::CodecID) video_codecs[(int) codec],
-			( codec == VideoCodec::Default ) ? libffmpeg::PIX_FMT_YUV420P : (libffmpeg::PixelFormat) pixel_formats[(int) codec] );
+		 add_video_stream( data, width, height, frameRate, bitRate,
+                        ( codec == VideoCodec::Default ) ? outputFormat->video_codec : (libffmpeg::CodecID) video_codecs[(int) codec],
+                        ( codec == VideoCodec::Default ) ? libffmpeg::PIX_FMT_YUV420P : (libffmpeg::PixelFormat) pixel_formats[(int) codec] );
 
 		// set the output parameters (must be done even if no parameters)
 		if ( libffmpeg::av_set_parameters( data->FormatContext, NULL ) < 0 )
@@ -185,6 +185,8 @@
 {
 	if ( data != nullptr )
 	{
+		Flush( );
+
 		if ( data->FormatContext )
 		{
 			if ( data->FormatContext->pb != NULL )
@@ -239,6 +241,58 @@
 	m_height = 0;
 }
 
+// Flushes delayed frames to disk
+void VideoFileWriter::Flush( )
+{
+	// This function goes by the data->VideoOutputBuffer extracting
+	// and saving to disk one frame at time, using mostly the same
+	// code which can be found on write_video_frame.
+
+	if ( data != nullptr )
+	{
+		int out_size, ret = 0;
+
+		libffmpeg::AVCodecContext* codecContext = data->VideoStream->codec;
+		
+		while ( 1 ) // while there are still delayed frames
+		{
+			libffmpeg::AVPacket packet;
+		    libffmpeg::av_init_packet(&packet);
+
+			// attempt to extract a single delayed frame from the buffer
+			out_size = libffmpeg::avcodec_encode_video(codecContext, data->VideoOutputBuffer, data->VideoOutputBufferSize, NULL);
+
+			if (out_size <= 0)
+				break; // there are no more frames to be written
+
+			// TODO: consider refactoring with write_video_frame?
+			if ( codecContext->coded_frame->pts != AV_NOPTS_VALUE )
+			{
+				packet.pts = libffmpeg::av_rescale_q( codecContext->coded_frame->pts, codecContext->time_base, data->VideoStream->time_base );
+			}
+
+			if ( codecContext->coded_frame->key_frame )
+			{
+				packet.flags |= AV_PKT_FLAG_KEY;
+			}
+
+			packet.stream_index = data->VideoStream->index;
+			packet.data = data->VideoOutputBuffer;
+			packet.size = out_size;
+
+			// write the compressed frame to the media file
+			ret = libffmpeg::av_interleaved_write_frame( data->FormatContext, &packet );
+
+			if ( ret != 0 )
+			{
+				throw gcnew VideoException( "Error while writing video frame." );
+			}
+		}
+
+		libffmpeg::avcodec_flush_buffers(data->VideoStream->codec);
+	}
+}
+
 // Writes new video frame to the opened video file
 void VideoFileWriter::WriteVideoFrame( Bitmap^ frame )
 {
@@ -301,6 +355,7 @@
 	write_video_frame( data );
 }
 
+
 #pragma region Private methods
 // Writes video frame to opened video file
 void write_video_frame( WriterPrivateData^ data )
@@ -383,47 +438,81 @@
 void add_video_stream( WriterPrivateData^ data,  int width, int height, int frameRate, int bitRate,
 					  enum libffmpeg::CodecID codecId, enum libffmpeg::PixelFormat pixelFormat )
 {
-	libffmpeg::AVCodecContext* codecContex;
+	    libffmpeg::AVCodec *codec = libffmpeg::avcodec_find_encoder(codecId);
+        libffmpeg::AVCodecContext* codecContex;
+        // create new stream
+        data->VideoStream = libffmpeg::avformat_new_stream( data->FormatContext, codec );
+        if ( !data->VideoStream )
+        {
+                throw gcnew VideoException( "Failed creating new video stream." );
+        }
+        
+        codecContex = data->VideoStream->codec;
+        codecContex->codec_id   = codecId;
+        codecContex->codec_type = libffmpeg::AVMEDIA_TYPE_VIDEO;
 
-	// create new stream
-	data->VideoStream = libffmpeg::av_new_stream( data->FormatContext, 0 );
-	if ( !data->VideoStream )
-	{
-		throw gcnew VideoException( "Failed creating new video stream." );
-	}
+        // put sample parameters
+        codecContex->bit_rate = bitRate;
+        codecContex->width    = width;
+        codecContex->height   = height;
 
-	codecContex = data->VideoStream->codec;
-	codecContex->codec_id   = codecId;
-	codecContex->codec_type = libffmpeg::AVMEDIA_TYPE_VIDEO;
+        // time base: this is the fundamental unit of time (in seconds) in terms
+        // of which frame timestamps are represented. for fixed-fps content,
+        // timebase should be 1/framerate and timestamp increments should be
+        // identically 1.
+        codecContex->time_base.den = frameRate;
+	    codecContex->time_base.num = 1;
 
-	// put sample parameters
-	codecContex->bit_rate = bitRate;
-	codecContex->width    = width;
-	codecContex->height   = height;
+	    codecContex->gop_size = 12; // emit one intra frame every twelve frames at most
+        codecContex->pix_fmt  = pixelFormat;
 
-	// time base: this is the fundamental unit of time (in seconds) in terms
-	// of which frame timestamps are represented. for fixed-fps content,
-	// timebase should be 1/framerate and timestamp increments should be
-	// identically 1.
-	codecContex->time_base.den = frameRate;
-	codecContex->time_base.num = 1;
+        if ( codecContex->codec_id == libffmpeg::CODEC_ID_MPEG1VIDEO )
+        {
+                // Needed to avoid using macroblocks in which some coeffs overflow.
+                // This does not happen with normal video, it just happens here as
+                // the motion of the chroma plane does not match the luma plane.
+                codecContex->mb_decision = 2;
+        }
 
-	codecContex->gop_size = 12; // emit one intra frame every twelve frames at most
-	codecContex->pix_fmt  = pixelFormat;
+        if ( codecContex->codec_id == libffmpeg::CODEC_ID_H264 )
+        {
+                data->VideoStream->need_parsing = libffmpeg::AVSTREAM_PARSE_FULL_ONCE;
 
-	if ( codecContex->codec_id == libffmpeg::CODEC_ID_MPEG1VIDEO )
-	{
-		// Needed to avoid using macroblocks in which some coeffs overflow.
-		// This does not happen with normal video, it just happens here as
-		// the motion of the chroma plane does not match the luma plane.
-		codecContex->mb_decision = 2;
-	}
+                codecContex->coder_type = 1; 
+                codecContex->flags|=CODEC_FLAG_LOOP_FILTER;
+				codecContex->flags2|=CODEC_FLAG2_BPYRAMID-CODEC_FLAG2_WPRED-CODEC_FLAG2_8X8DCT;
+                codecContex->profile=FF_PROFILE_H264_BASELINE;
+                codecContex->scenechange_threshold = 40; 
+				codecContex->gop_size=250;
+				codecContex->max_b_frames=0;
+				codecContex->max_qdiff=4;
+                codecContex->me_method=10;
+				codecContex->me_range=16;
+                codecContex->me_cmp|= 1;
+                codecContex->me_subpel_quality = 6; 
+				codecContex->qmin=0; 
+				codecContex->qmax=69;
+				codecContex->qcompress=0.6f;
+				codecContex->keyint_min=25;
+				codecContex->trellis=0;
+				codecContex->level=13;
+                codecContex->refs = 16;
+                codecContex->weighted_p_pred = 2;
+				codecContex->b_frame_strategy= 1;
+				codecContex->color_range = libffmpeg::AVCOL_RANGE_JPEG;
+                codecContex->crf = 0;
+        }
 
-	// some formats want stream headers to be separate
-	if( data->FormatContext->oformat->flags & AVFMT_GLOBALHEADER )
-	{
-		codecContex->flags |= CODEC_FLAG_GLOBAL_HEADER;
-	}
+		if ( codecContex->codec_id == libffmpeg::CODEC_ID_THEORA )
+        {
+				codecContex->color_range = libffmpeg::AVCOL_RANGE_JPEG;
+		}
+
+        // some formats want stream headers to be separate
+        if( data->FormatContext->oformat->flags & AVFMT_GLOBALHEADER )
+        {
+                codecContex->flags |= CODEC_FLAG_GLOBAL_HEADER;
+        }
 }
 
 // Open video codec and prepare out buffer and picture
Index: Sources/Video.FFMPEG/VideoFileWriter.h
===================================================================
--- Sources/Video.FFMPEG/VideoFileWriter.h	(revision 1699)
+++ Sources/Video.FFMPEG/VideoFileWriter.h	(working copy)
@@ -294,6 +294,8 @@
         /// 
 		void WriteVideoFrame( Bitmap^ frame, TimeSpan timestamp );
 
+		void Flush( );
+
         /// <summary>
         /// Close currently opened video file if any.
         /// </summary>
